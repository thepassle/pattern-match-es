class Stub {
  constructor(fn) {
    this._calls = new Set();
    this.original = fn;
    this.handler = (...args) => {
      return this._handleCall(...args);
    };
  }
  get called() {
    return this._calls.size > 0;
  }
  get calls() {
    return this._calls;
  }
  getCall(index) {
    return [...this._calls][index];
  }
  get firstCall() {
    return this.getCall(0);
  }
  get lastCall() {
    return this.getCall(this.callCount - 1);
  }
  get callCount() {
    return this._calls.size;
  }
  _handleCall(...args) {
    const returnValue = this._returnFunction ? this._returnFunction(...args) : this._returnValue;
    this._calls.add({
      args,
      returnValue
    });
    return returnValue;
  }
  returns(val) {
    this._returnFunction = void 0;
    this._returnValue = val;
  }
  callsFake(fn) {
    this._returnValue = void 0;
    this._returnFunction = fn;
  }
  passThrough() {
    this.callsFake(this.original);
  }
  reset() {
    this._calls.clear();
  }
  restore() {
    this.restoreCallback?.();
  }
  calledWith(...args) {
    return [...this.calls].some((call) => call.args.length === args.length && call.args.every((arg, idx) => args[idx] === arg));
  }
  returned(val) {
    return [...this.calls].some((call) => call.returnValue === val);
  }
}
const stubbedMethods = new Set();
function stubMethod(obj, method) {
  const instance = new Stub(obj[method]);
  obj[method] = instance.handler;
  instance.restoreCallback = () => {
    obj[method] = instance.original;
    stubbedMethods.delete(instance);
  };
  stubbedMethods.add(instance);
  return instance;
}
function stub(fn) {
  const result = new Stub(fn);
  return result;
}
function spy() {
  return new Stub(() => {
    return;
  });
}
function restore() {
  for (const stub2 of stubbedMethods) {
    stub2.restore();
  }
  stubbedMethods.clear();
}
export {
  Stub,
  restore,
  spy,
  stub,
  stubMethod
};
